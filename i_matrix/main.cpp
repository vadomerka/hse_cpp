
/*
 * Разработать класс Матрица, который удовлетворяет следующим требованиям:
 * 1) Для представления элементов матрицы будем использовать наиболее
 * компактное. 2) Используем правильное управление ресурсами (памятью):
 *  + Распределение
 *  + Освобождение
 *  - Глубокое копирование
 * 3) Добавляем операционную семантику, ожидаемую для математического
 * объекта Матрица (сложение, умножение, транспонирование, проверка
 * на равенство/неравенство)
 *  - Сделаем перегрузку операторов...
 * 4) Для представления составных элементов матрицы (столбцы, строки)
 * создадим легковесные обертки, которые можно будет передавать по значению
 * (аналогия с итераторами и string_view). Не забываем про константность
 * 5) Добавляем в матрицу умение быть хорошо воспитанным контейнером:
 * Итераторы, begin'ы, end'ы и тд.
 * 6) Научим матрицу быть перемещаемым объектом (НЛО)
 * 7) Сделаем матрицу шаблоном, чтобы это была матрица произвольных объектов
 * (Матрица T)
 * Требования и ограничения
 * a) Будем тестировать матрицу обычными assert'ами
 */

#include <cassert>
#include <iostream>

#include "matrix.h"

void test01() { 
  assert(true); 
}

void test02() {
  Matrix m;
  assert(true);
}

void test03() {
  Matrix m(3, 4, 42);
  assert(m.GetRowsNum() == 3 && m.GetColsNum() == 4);
  assert(m.At(0, 0) == 42);
}

void PrintMatrixRow(Matrix::Row row) {
  // row[0] // нулевой элемент переданной строки
  for (size_t j = 0; j < row.Size(); j++)
  {
    std::cout << row[j] << ' ';
  }
}

// Передаем row по значению, потому что это похоже на итератор (а они передаются по значению).
void DoubleRow(Matrix::Row row) {
  // row[0] // нулевой элемент переданной строки
  for (size_t j = 0; j < row.Size(); j++)
  {
    row[j] *= 2;
  }
}

void test04() {
  Matrix m(3, 4, 42);
  // Matrix::Row row(1, &m); // Возможно, но недопустимо.
  PrintMatrixRow(m[1]);
  DoubleRow(m[1]);
  PrintMatrixRow(m[1]);
  // PrintMatrixRow(m[1]); // Распечатывает 1 строку.
  // PrintMatrixRow(m(2)); // Распечатывает 2 столбец.
}

void PrintKthRow(const Matrix& m, size_t k) {
  // PrintMatrixRow(m[k]);
}

void test05() {
  Matrix m(3, 4, 42);
  PrintKthRow(m, 1);
}

int main() {
  int&& rx = 6;

  int& lx = rx;
  std::cout << "Allright";
  return 0;
}
